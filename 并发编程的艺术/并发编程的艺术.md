# 2020学习计划
## 基础知识
整型：
byte:1个字节 8位 -128~127

short ：2个字节 16位 (-2^15 ~ 2^15-1)

int ：4个字节 32位 (-2^31 ~ 2^31-1)

long：8个字节 64位 (-2^63 ~ 2^63-1)

浮点型：
float：4个字节 32 位

double ：8个字节 64位

注：默认的是double类型，如3.14是double类型的，加后缀F（3.14F）则为float类型的。

char类型：2个字节。

Boolean 类型:（true or false）（并未指明是多少字节  1字节  1位 4字节）

补充：BigInteger类实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。
## 1. 背java面试题
    1. String能被继承吗？为什么？
    不可以,String是final的不能被继承
    String a = "123"和String a = new String("123")是有区别的
    前者为显示声明,存储在堆中的常量池里,后者非显式赋值,编译器在堆中重新分配区域存放它的实例对象,而在栈中存放此对象引用
    举个例子
    String str1="abc";
    String str2="abc";
    String str3="ab"+"c";
    String str4=new String(str2);
    结论
    第一种 str1=str2 原因是他们都是显式存储,"abc"被存储在常量池中,他们的引用都指向常量池中的"abc"
    第二种 str1=str3 原因是编译器做了优化,会先将字符串拼接起来去常量池中查找这个字符串,如果存在则直接引用,没有则新增一个
    第三种 str1!=str4 非显式存储会在堆里规划一块地方存对象实例,所以str1引用指向常量池,而str4的引用指向堆里的其他区域
    2. String， Stringbuffer， StringBuilder 的区别
    String字符串常量,final创建后不能修改
    StringBuffer字符串变量,线程安全,final,绝大多数方法都进行了同步处理,用synchronized修饰,出现于jdk1.0.
    其中toString方法进行了对象缓存,减少复制开销
```` java
    public synchronized String toString() {
    	if (toStringCache == null) {
    		toStringCache = Arrays.copyOfRange(value, 0, count);
    	}
    	return new String(toStringCache, true);
    }
````

## 2. 数据库知识点
    1. 分库分表原则（垂直和水平）
    2. 三大范式概念以及理解
    3. 表设计、冗余、增量、主键生成规则种类及优劣、外键优劣
    4. 索引的类型与区别
    5. 执行计划-sql和索引的执行顺序，慢sql分析
    6. 红黑树,二叉树等数据库存储原理
    7. 数据库调优方式
## 3. 设计模式
    1. 23种设计模式概念、使用场景、优缺点及类关系图
    2. 相似的设计模式间的区别，如装饰模式和适配器模式
    3. 整理出项目中用到的设计模式
## 4. 性能设计
    1. 缓存设计(redis)
    2. 多线程(内存分布,方法区,程序计数器,堆,栈)
    3. 负载平衡(nginx)
    4. 文件系统优化(NIO)
## 5. 并发编程
### 1.1 上下文切换
    1. 单核处理器也支持多线程执行代码，cpu给每个分配时间片实现
    2. 时间片很短，一般是几十毫秒（ms）
    3. 一个任务从保存到再加载的这个过程叫做一次上下文切换
    4. 切换上下文需要时间，上下文切换会影响多线程的执行速度
    5. 并发执行并不一定比串行快，线程的创建和上下文切换会增加时间开销
    6. Lmbench3是一个性能分析工具，可以测量上下文切换时长。
       vmstat命令可以测量上下文切换次数
    $ vmstat 1 
    procs -----------memory------- -swap- -io-- -system-- -----cpu----- 
    r b swpd  free    buff   cache  si so bi bo  in  cs  us sy id wa st 
    0 0 0    127876  398928 2297092 0  0  0  4   2   2   0  0  99 0  0 
    0 0 0    127868  398928 2297092 0  0  0  0  595 1171 0  1  99 0  0  
    0 0 0    127868  398928 2297092 0  0  0  0  590 1180 1  0 100 0  0 
    0 0 0    127868  398928 2297092 0  0  0  0  567 1135 0  1  99 0  0
    
    CS（Content Switch）表示上下文切换的次数
    7. 减少上下文切换的方法有，无锁并发编程，CAS算法，使用最少线程和使用协程
        1）避免使用锁，用其他方法替换，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据
        2）Atomic包使用CAS算法无锁更新数据
        3）尽量少的创建线程，如任务少线程多，会造成大量线程等待
        4）单线程多任务调度，并在单线程里维持多个任务的切换
    8. 减少上下文切换实战
        1. 第一步用jstack语法dump线程信息
![RUNOOB jstack语法](http://106.13.174.85:8080/test/images/concurrent/jstack.png)
        2. 第二步查看线程状态
![RUNOOB jstack语法](http://106.13.174.85:8080/test/images/concurrent/jstack2.png)

### 1.2 死锁
    1. 资源的类型
        1）可重用资源（永久性资源）和消耗性资源（临时性资源）
        2）可抢占资源（CPU 和主存等）和不可抢占资源（打印机和磁带机等）
    2. 死锁产生的原因
        1）竞争不可抢占资源引起死锁
        2）竞争可消耗资源引起死锁
        3）进程推进顺序不当引起死锁
    3. 死锁产生的四个必要条件
        1）互斥
            在一段时间内某资源仅为一个进程所占有
        2）不可剥夺
            线程获取的资源不可被强行剥夺，其他线程只能等待它主动释放
        3）请求与保持
            线程至少保持一个资源，然后请求新资源
        4）循环等待
            资源的循环等待链，每一个线程所获取的资源同时被链中的下一个线程所请求
    4. 避免死锁的方法
        1）避免一个线程同时获取多个锁
        2）避免一个锁同时占用多个资源，尽量一个资源一个锁，也就是锁的粒度尽可能小
        3）尝试定时锁，使用lock.tryLock（timeout）代替内部锁
        4）对于数据库锁，加锁解锁都必须要在一个数据库连接里，否则会解锁失败
        5)[银行家算法](https://blog.csdn.net/wljliujuan/article/details/79651932/)
    5. 处理死锁的方法
        1）取消互斥，互斥无法破坏，主要是破坏其他三个必要条件。
        2）破坏“占有并等待”条件
            方法一：创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。这是所谓的 “ 一次性分配”方案。
            方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。
        3）破坏“不可抢占”条件
            方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。
            方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。
        4）破坏“循环等待”条件
            破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。
    6. 解除死锁
        一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。
        死锁解除的主要方法有：
        1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。
        2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。
        3) 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。
### 1.3 资源限制
    资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。
    1. 硬件资源限制
        带宽大小，硬盘读写速度，cpu处理速度
    2. 软件资源限制
        数据库连接数，socket连接数等
        
### 2.1 内存模型
    cpu，高速缓存（L1，L2，L3三级缓存）和主存的关系
    缓存一致性协议 https://www.cnblogs.com/yanlong300/p/8986041.html
        MESI
        锁缓存锁总线
    volatile实现原理
        ，非锁，保证可见性和有序性，无法保证原子性
        1.转化为带lock前缀的汇编指令将缓存的值写会内存里面，一般是锁缓存不锁总线
        2.处理器则会用MESI控制协议是其它cpu缓存中的值状态变为I（值无效，需要重新从主存读取）
        volatile优化
            追加字节，jdk7以后有效
                LinkedTransferQueue，PaddedAtomicReference，AtomicReference将共享变量追加15个对象引用，加上父类的value变量，一共16个占64个字节，cpu一个缓存行刚好64个字节，锁缓存行不需要锁住其它变量
                
                注意：有两种情况不能使用此方法
                    1. 缓存行非64字节宽的处理器，如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个 字节宽
                    2. 共享变量不会被频繁地写，没必要
    
    Synchonized
        重量级锁，锁总线，jdk6优化引入了“偏向锁”和“轻量级锁”，使它变得不那么重
## 3 内存模型
### 3.1 基础
	1. 线程的两种通信机制:
		共享内存
			概念:线程共享程序的公共状态,通过写-读内存中的公共状态进行隐式通信
			同步:必须显式制定某个方法或者某段代码需要在线程间互斥执行
		消息传递
			概念:消息传递并发模型,线程间没有公共状态,线程间通过发送消息显式通信
			同步:发送必须在接收之前,隐式进行
			
	2. 同步是指控制不同线程间的操作发生相对顺序的机制
	3. java并发采用共享内存模型
	4. 重排序优先级：源码>编译器优化>指令级并行>内存系统>最终执行
	5. JMM和JVM的区别
	6. java5之后增强了volatile语义，happens-beform六大规则
	    程序顺序规则：单线程中，前面早于后面执行
	    监视器锁规则：解锁早于再加锁
	    volatile变量规则：volatile的写早于下一个读
	    传递性：A>B,B>C则A>C
	    线程start规则：父线程早于子线程
	    线程join()规则
	7. as-if-serial语义，不会对有数据依赖性的代码做重排序
	8. 数据依懒性：写后读，读后写，写后写
	
	    
